---
title: Networking
---

Iron Fish is a decentralized cryptocurrency. As such, Iron Fish relies on a peer-to-peer network of nodes to perform all operations, including:

- validating and accepting mutations to the chain (explained in detail in [Protocol](https://www.notion.so/Protocol-bcd27b53f3ce459e8e8dce23521c2445?pvs=21))
- distributing a copy of the chain to other nodes
- distributing pending [transactions](https://www.notion.so/Transactions-0d0b05511fb8401881d6493fe30b57db?pvs=21) to other nodes
- discovering other nodes in the network

Before digging into the details of how nodes share the chain and the transactions, it is important to understand that there can be many instances of Iron Fish network. There are two official instances of the Iron Fish network:

- **mainnet:** used for production. This is the network version that is supported by exchanges and miners.
- **testnet:** used for testing. Major changes to consensus are tested on the testnet before being applied on the mainnet

What differentiates an Iron Fish network instance from another is its **network definition**, described below. Different Iron Fish networks with different network definitions are incompatible with each other, and a node from one network will not accept chain mutations coming from a node from another network.

# Network Definition

A network is defined by the following two parameters:

- network id: an unsigned 16-bit integer
- genesis block: the block with block sequence 1

These parameters cannot be changed. Attempting to change these parameters would give rise to a new network.

The genesis block is the first block in the chain and may be used to create the first notes.

The following are the network id and genesis block hashes for the official Iron Fish networks:

|         | Network ID | Genesis Block Hash                                                 |
| ------- | ---------- | ------------------------------------------------------------------ |
| Mainnet | 1          | `eac623b099b8081d2bde92d43a4a7795385c94e2c0ae4097ef488972e83ff2b3` |
| Testnet | 0          | `7999c680bbd15d9adb7392e0c27a7caac7e596de5560c18e96365d0fd68140e3` |

A network definition may be associated to a [consensus](https://www.notion.so/Consensus-3eb91b5d0cba4b12b6ac76a254ebd597?pvs=21), although the consensus is not strictly part of the network definition, and is allowed to change over time.

A network definition may be associated to a list of [bootstrap nodes](https://www.notion.so/Networking-23c1d6e8c1884a17a4e378b763e92d77?pvs=21): these are nodes with a fixed network address (for example: a static IP address, or a DNS name) that facilitate peer discovery. Bootstrap nodes may be regular nodes, but in most cases they are configured so that they do not actively participate to the network. In any case, they do not affect the security properties or the decentralization properties of the network. Bootstrap nodes are also not part of the network definition, are allowed to change over time, and are optional.

# Peer Communication

Iron Fish nodes perform communication over UDP/IP using [WebSocket](https://en.wikipedia.org/wiki/WebSocket) and WebRTC. The messages exchanged over WebRTC use a custom binary serialization format.

Because most nodes are expected to be behind NAT firewalls that don’t allow incoming connections, Iron Fish uses hole punching through STUN servers.

# Peer Discovery

The Iron Fish peer-to-peer network can be arbitrarily large, and for practical reasons each node will connect to a subset of peers. The maximum number of peers that a node will connect to may be defined by software limits or operating system limits, and for the reference implementation of the Iron Fish node this number is 50.

When a node comes online for the first time, it may connect to one or more **bootstrap nodes** in order to find an initial set of peers. A bootstrap node is a node that has a known, fixed address (which is generally hardcoded inside the software, along with the network definition), and serves the purpose of keeping track of the list of peers that connect to it, and sharing this list to new peers.

Once a node has obtained a list of peers, it can connect to them, and ask them for their list of peers, and continue this process until all the reachable peers have been connected, or the maximum number of connections is reached.

After the first peer discovery, the node may cache the list of discovered peers so that subsequent restarts do not have to rely on bootstrap nodes.

# Block Sharing

Peers share blocks using a custom [gossip protocol](https://en.wikipedia.org/wiki/Gossip_protocol). Whenever a new block is mined, it is broadcasted to all the nodes in the network through the gossip protocol.

The reference implementation of the Iron Fish node employs some strategies to reduce the amount of data exchanged (and, in particular, to avoid re-sending the same block to the same nodes multiple times).

# Transaction Sharing

When an Iron Fish participant wants to post a new transaction to the Iron Fish chain, they will initially broadcast it as a **pending transaction** to the Iron Fish nodes in the network. The miners will listen for the pending transactions and perform work to mine blocks including some or all of the pending transactions.

Pending transactions are put into a data structure called **mempool**. The mempool can be thought of a queue of pending transactions that are waiting to be mined. The mempool is ephemeral and completely disconnected from the Iron Fish chain. Nodes share their mempool with their peers.

Nodes should validate all individual pending transactions before accepting them in their mempool. Note however that it’s theoretically possible to have multiple pending transactions that are in conflict with each other (for example, “double spend” transactions). Mining is the operation that discriminates between conflicting transactions. For this reason, the mempool should never be used as a source of truth for anything; only the canonical chain can provide sufficient assurance about valid transactions.
